<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <script>
        
        // [ 복습 ] 

        // 변수 선언 방식 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

        // //옛날 방식
        // asdf = 20;


        // // ES5 방식
        // var a = 10; 
        // console.log(a);

        // // ES6 방식
        // let k = 1;
        
        // // const c = 10;
        // // const c; // <-- 안됨 오류 남 (자바스크립트는 자바와 달리 값을 보고 데이터 타입을 정하는 방식이라 그럼)
        // let d; // 는 됨
        


        // // typeof(), isArray()-----------------------------------------------

        // // typeof()
        
        // let a = 10;
        // let c = 'abc';
        // let ar = [11, 22, 33];

        // console.log(typeof(a));  // number
        // console.log(typeof(c));  // string 
        // console.log(typeof(ar));  // object

        // // Array.isArray()

        // console.log( Array.isArray(ar) );   //true
        // console.log( Array.isArray(ac) );   //false
       

        /*  
         왜 ""보다 ''로 하는 것이 낫다는 건지 검색해보기
       */

        // concat(), toFixed() ////////////////////////////////////////////////
        

        // // concat()

        // let str1 = 'aabbcc';
        // let str2 = 'kk';
        
        // let str3= str1.concat(str2);
        // console.log(str3);  //aabbcckk
        
        
        // // toFixed()

        // let a = 3.14159;
        // let result = a.toFixed(2);
        
        // console.log(result); // 3.14
        // console.log(typeof(result)); //string

        // // ▲ 자바 스크립트는 라이브러리의 리턴형을 잘 알고 써야한다.
        // // tofixed는 숫자를 넣었는데 문자열로 반환한다.
        // // 자바 스크립트는 이런 경우가 많다.
        // // 블로그같은데에서 라이브러리 사용법을 익히더라도 한번 쯤은 래퍼런스를 들어가서 봐야한다.


        /*
            문자열은 연산자, 라이브러리 공부할 것
        */

        ///////////////////////////////////////////////////////////////////////////

        // // 1. 선언함수(ES5) : 함수명이 존재
        // function myfunc1(a, b)
        // {
        //     return a + b;
        // }

        // // 2. 익명함수(ES6) :함수명이 존재 하지 않음.
        // const myfunc2 = function(a, b)
        // {
        //     return a + b;
        // }        

        // let myfunc3 = myfunc2; //함수 참조변수를 넣어서 함수를 사용하는 것도 가능하다.
        // console.log(myfunc3(5, 6)); 
        
        // const testFuction = function()
        // {   
        //     const ff  = 1; 
        //     const f   = function() { console.log("aaaa"); }  //

        //     console.log(ff);
        //     console.log(f());
        // }

        // // f(); // 호출이 안 된다. 스코프가 있기 때문

        // testFuction();


        /////////////////////////////////////////////////////////////////
        
        // //가변 파라미터

        // //파리미터로 들어온 값을 다 더해서 리턴하는 함수
        // const func = function(...ar)
        // {
        //     let total = 0;
            
        //     for(const val of ar)
        //     {
        //         total += val;
        //     }

        //     return total;
        // }


        // // 스프레드 연산자?

        // const ar = [1, 2, 3];
        // func(...ar); // ==
        // func(ar[0], ar[1], ar[2]);


        ////////////////////////////////////////////////////////////////

        // // forEach 만들어보기 
        // const forEach = function(ar, f)
        // {
        //     for (let i = 0; i < ar.length; i++)
        //     {
        //         f(ar[i], i, ar)
        //     }
        // }
        
        
        // const ar = [11, 22, 33, 44, 55];
        // const func = function(value, index, ar)
        // {
        //     console.log(value)
        //     console.log(index)
        //     console.log(ar)
        // }
        // forEach(ar, func);




        // ------------------------------------------------------------------------------------

        // const myCallback = function(value, index, array)
        // {
        //     console.log(value)
        // } 

        // const ar = [11, 22, 33, 44, 55];
        // ar.forEach(myCallback)


        // // ar.forEach
        // // ( 
        // //     function(value, index, array) {console.log(value) } 
        // // )
        // // 함수 참조변수를 넣지 않고 이렇게 파라미터 안에 함수 생성을 넣어도 잘 돌아간다.






        // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
        // 문제1. [‘홍길동, ‘세종대왕’, ‘김구‘, ‘안중근’] 배열의 각 요소에 “훌륭한＂이라는 말머리를 붙이는 코드를 map()을 이용하여 작성하시오

        // let ar = ['홍길동', '세종대왕', '김구', '안중근' ];

        // const callbackF = function(string)
        // {
        //     return '훌륭한 ' +string;
        // }

        // str2 = ar.map(callbackF);
        // console.log(str2);







        // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
        // Arrow 함수 --> ES6에 새로 나온 기능

        // const number = [10, 20, 30, 40, 50];

        // // const new_num = number.map( function(value){ 
        // // return value + 5;
        // // });
        // // ▼
        
        // const new_num = number.map( (value)=> value + 5 );
        // // expression에는 ;을 붙일 수 없다. statement에 붙일 수 있다.

        // console.log(new_num); // 15, 25, 35, 45, 55

        // /*
        //     arrow 함수는 함수와 거의 비슷하나 내부적으로는 다르다.
        //     나중에 설명한다고 함.
        //     return 생략 가능
        // */

        



        
        // 연습문제 ----------------------------------------------------------   
        // 배열의 각요소에 +5를 한 뒤 30보다 큰값만을 뽑아낸다.

        // const number = [10, 20, 30, 40, 50];     

        // const new_num = number.map( (value)=> value + 5 );
        // const new_num2 = new_num.filter( (value)=> value > 30);

        // console.log(new_num);
        // console.log(new_num2);
        






        // 메소드 체이닝. <<-- 임시변수  -------------------------------------
        
        // const number = [10, 20, 30, 40, 50];    
        
        // const new_num2 = number.map( (value)=> value + 5 ).filter( (value)=> value > 30);
            
        // console.log(new_num2);
        
        // /*
        //     과도한 메소드 체이닝은 코드 복잡도를 올리기 때문에 2~3단계 안으로만 하는 게 좋다.
        // */

        




        // // 문제2. ------------------------------------------
        // // 아래 배열에서 짝수만 도출한 뒤 이를 두배하시오.

        // const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        // const new_numbers = 
        //     numbers.filter( (value) => (value % 2 === 0))
        //            .map( (value) => (value *2) )


        // console.log(new_numbers);




    </script>






 <!-- ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
      객체형                                                                --> 
 <!--  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ -->

 <script>
    (function(){


        // object 생성 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

        // const product ={

        //     name : 'mouse',
        //     type : 'wireless',
        //     color : 'black',
        //     buttons : 6,
        //     scroll : true,
        //     aaa : [11, 22, 33],

        // };  // heap에 메모리가 잡힌다. {}까지가 객체이고, product 에 참조값을 집어넣는다. 
        // // key - value 형식으로 만든다.
        // // value 로는 다 들어갈 수 있다.

        // console.log(product);
        // console.log(typeof(product));
        


        // // 객체 reading ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

        // console.log(product.name);   //mouse
        // console.log(product.type);   //wireless
        
        // console.log(product['name']);  // mouse
        // // console.log(product[name]); //  undefined
        

        // const a = 'scro';
        // console.log(product[`${a}ll`]); //true
        // console.log(product[`${a}`]); // undefined


        // product.buttons = 9;
        // console.log(product.buttons); // 9 
        

        // product.led = true;
        // console.log(product); // led 추가됨.
        // // --->  오타에 취약하다. 오타주의가 필요하다.
        



        // // delete ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


        // product.button = 7;
        // console.log(product);
       
        // delete product.button;
        // console.log(product);  // 추가된 button이 삭제된다.





    //     // 문제 3 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

    //     // 학생 객체
    //     // ----------------------
    //     // 이름
    //     // 나이
    //     // 학번
    //     // 성적 : 국어점수, 영어점수, 수학점수

    //     //console로 속성을 출력해보세요.



    //     let score = [10, 20, 30];

    //     const student = {
    //         name : '손영호',
    //         age : '31',
    //         number : '11111',
    //         score : [80, 90, 100],
              
    // // 메소드 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    //         getTotal : function(){   
    //             let total = 0;

    //             // this : 해당 메소드를 소유하고 있는 객체의 시작정보(래퍼런스)
    //             //    getTotal 메소드를 소유하고 있는 student객체의 시작정보
    //             for (const val of this.score)  // this 대신 student 라고 써도 된다.
    //             {
    //                 total = total + val;
    //             }
    //             return total;
    //         },



    //         // printName : function(){
    //         // printName() { // ES6에서는 ' printName : function() ' ==> ' printName() '로 할 수 있다.
    //         printName : ()=>{

    //             console.log("abc");
    //             console.log(this.name); // 화살표 함수에서는 this는 window를 가르킨다. window가 소유하기 때문
    //             console.log(student.name);
                
    //             console.log(this)  // 화살표함수는 소유자가 객체가 아니라 전역객체다.
    //             // 브라우저에 있는 객체 중에서 window 객체가 가장 최상위 객체이다.
    //             // 지금은 전역객체가 window 객체라고 생각하면 된다.
    //             // 화살표 함수의 소유자가 window다.

    //             // ★ 메소드는 화살표 함수로 쓰지 않는 것이 좋다. this 를 못 쓰기 때문에
    //             // 화살표 함수는 자바의 전역 영역 메소드와 비슷하다.
    //         }
  
            
          
    //     };

    //     console.log(student.name);
    //     console.log(student.age);
    //     console.log(student.number);
    //     console.log(student.score);

    //     console.log(student.getTotal());
    //     student.printName();


    
    // 리터럴 object  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    // const 객체이름 = {}  // <-- ES 6 방식
                            // ES6 전에는 new 로 했음.



    //    // 슈거코드 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ                     
    //    const x = 1;
    //    const y = 2;
       
    //    const obj = {
    //     x,       // 기존 변수와 값이 동일한 목적으로 할 경우에는 이렇게 할 수도 있다.
    //     y,        // 슈거 코드임. 가급적이면 슈거 코드를 쓰지말아야함. 이점이 있어야만 쓰는 게 슈거코드다.
       
    //         myfunc : function(a, b)
    //         // myfunc(a, b)   왠만하면 원형을 지키는 게 좋다.
    //         {
    //             return a + b;
    //         }
    
    
    //     }

        // for-of 를 써야만 하는 경우ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

        // const student = {
        //     name : "정성훈",
        //     age : 49,
        //     addr : "서울 동대문구",
        //     married : true

        // };

        // // for (const val of student)
        // // {
        // //     console.log(val);       
        // // }

        // for (const val in student)
        // {
        //     console.log(val);
        //     console.log(`${val} = ${student[val]}` );
        
        // }
                    
    


        // 문제 4 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

        const product = {
            name : 'Macbook Pro',
            type : 'notebook',
            USB : 3,
            price : 1300,

            printName : function()
            {
                console.log(this.name);
            },

            getTotalPrice : function(count)
            {   
                if(count < 0)
                return;

                total = this.price * count;


                if(count < 10)
                    return total;
                else
                    return total*0.9;    
                    
            }
        }

        product.supportedLanguage = ['kor', 'chi', 'eng', 'jap'];

        console.log(product);










    })();

    (() => {
    })();


</script>










</body>
</html>