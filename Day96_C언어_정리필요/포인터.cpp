//#include <stdio.h>
//
//// 포인터
//
//int main()
//{
//	int a = 10;
//	
//					// 포인터는 * 기호를 쓴다.
//	int* p = &a;   // address로부터 얼마큼 참조할 수 있는지를 지정해줘야 하기 때문에 int를 써줘야 한다
//					// a의 address 주소를 p에 담는다.
//
//
//	printf("%d\n", a);		// a에 저장되어 있는 값
//	printf("%d\n", *p);		// a의 시작주소에서 4바이트만큼 읽은 값
//		// 그냥 p라고 하면 안 되고, *p 라고 해야 해당 a의 값을 읽는다.
//
//
//
//	void* p = &a; // 이렇게 하면 address값만 가져온다. 범위를 모르기 때문에 값을 불러 올 수는 없다.
//
//
//	// 포인터는 위의 용도로 사용하지 않는다.
//	// 포인터의 용도는 무엇일까
//	
//	// heap에 메모리를 잡을 때, 그 메모리 블럭을 접근하기 위한 용도로 사용된다.
//	// 이름이 없는 놈들, address만 있는 얘들을 접근하기 위한 용도로 사용된다.
//
//	int* p = (int* )malloc(40);		// 메모리 얼로케이션하면 힙에 40바이트를 잡아준다. 그리고 리턴값을 어드레이스값으로 준다.
//									// malloc()은 c언어에서 힙에 메모리를 잡는 유일한 함수다.
//									// malloc()은 void* 이기 대문에 형변환해야 한다.
//									
//	// int* p 와 int *p 어떻게 붙이냐는 논란이 있었다. 
//	// 결론으로 말하자면 int* p 가 의미상으로 더 맞고, *p 로 해도 틀린 것은 아니다.
//	
//	int* p = (int*)malloc(sizeof(int) * 5);		// 보통 이렇게 데이터 크기 * 5개 이렇게 한다
//	int i;
//
//	*(p + 0) = 0;
//	*(p + 1) = 11;
//	*(p + 2) = 22;
//	*(p + 3) = 33;
//	*(p + 4) = 44;
//
//	for (i = 0; i < 5; i++)
//		printf("%d\n", *(p + i) );		// 11, 22, 33, 44, 55
//
//	// 이렇게 할 수 있다.
//
//
//	int ar[5];
//	int* p = ar;
//
//
//	*(p + 0) = 0;
//	p[0] = 0
//  
//	// 둘은 똑같은 거다. 슈거코드
//
//
//}